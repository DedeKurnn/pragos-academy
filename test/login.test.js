/* eslint-disable no-undef */

import { render, fireEvent, screen, waitFor } from "@testing-library/react";
import Login from "../src/pages/AuthFlow/Login"; // Import your Login component here
import app from "../src/lib/axiosConfig"; // Import the app or API module used for login
import { jest } from "@jest/globals";
import { ValidationContextProvider } from "../src/context/ValidationContext";
import { BrowserRouter } from "react-router-dom";
import { act } from "react-dom/test-utils";
import "@testing-library/jest-dom";
import toast from "react-hot-toast";

// Generated by CodiumAI

describe("Login", () => {
	// User enters valid email and password, submits form, and is redirected to dashboard if user role is admin
	it("should redirect to dashboard when user role is admin", () => {
		// Mock the necessary dependencies
		const appPostMock = jest.spyOn(app, "post").mockResolvedValueOnce({
			status: 200,
			data: {
				data: "[ROLE_ADMIN]",
			},
		});
		const toastErrorMock = jest.spyOn(toast, "error");

		// Render the component
		render(
			<BrowserRouter>
				<ValidationContextProvider>
					<Login />
				</ValidationContextProvider>
			</BrowserRouter>
		);

		// Fill in the form fields
		act(() => {
			fireEvent.change(screen.getByLabelText("Email"), {
				target: { value: "admin@email.com" },
			});
			fireEvent.change(screen.getByLabelText("Password"), {
				target: { value: "admin1234" },
			});

			// Submit the form
			fireEvent.click(screen.getByRole("button", { name: "Masuk" }));
		});

		// Assertions
		expect(appPostMock).toHaveBeenCalledWith(
			"login",
			{ email: "admin@email.com", password: "admin1234" },
			{
				headers: {
					"Content-Type": "application/json",
					Accept: "*/*",
				},
			}
		);
		expect(window.location.href).toBe("http://localhost/");
		expect(toastErrorMock).not.toHaveBeenCalled();

		// Clean up
		appPostMock.mockRestore();
		toastErrorMock.mockRestore();
	});

	// User enters valid email and password, submits form, and is redirected to home page if user role is not admin
	it("should redirect to home page when user role is not admin", () => {
		const appPostMock = jest.spyOn(app, "post").mockResolvedValueOnce({
			status: 200,
			data: {
				data: "[ROLE_USER]",
			},
		});

		// Render the component
		render(
			<BrowserRouter>
				<ValidationContextProvider>
					<Login />
				</ValidationContextProvider>
			</BrowserRouter>
		);

		act(() => {
			// Fill in the form fields
			fireEvent.change(screen.getByLabelText("Email"), {
				target: { value: "triniti940@bmobilerk.com" },
			});
			fireEvent.change(screen.getByLabelText("Password"), {
				target: { value: "TestUser123!" },
			});

			// Submit the form
			fireEvent.click(screen.getByRole("button", { name: "Masuk" }));
		});

		// Assertions
		expect(appPostMock).toHaveBeenCalledWith(
			"login",
			{ email: "triniti940@bmobilerk.com", password: "TestUser123!" },
			{
				headers: {
					"Content-Type": "application/json",
					Accept: "*/*",
				},
			}
		);
		expect(window.location.href).toBe("http://localhost/");

		// Clean up
		appPostMock.mockRestore();
	});

	// User enters valid email and password, submits form, and is not redirected if user role is not admin and user is already on home page
	it("should not redirect if user role is not admin and user is already on home page", () => {
		// Mock the necessary dependencies
		const appPostMock = jest.spyOn(app, "post").mockResolvedValueOnce({
			status: 200,
			data: {
				data: "[ROLE_USER]",
			},
		});
		const toastErrorMock = jest.spyOn(toast, "error");

		// Set the current URL to the home page
		Object.defineProperty(window, "location", {
			value: {
				href: "/",
				writable: true,
			},
		});

		// Render the component
		render(
			<BrowserRouter>
				<ValidationContextProvider>
					<Login />
				</ValidationContextProvider>
			</BrowserRouter>
		);

		act(() => {
			// Fill in the form fields
			fireEvent.change(screen.getByLabelText("Email"), {
				target: { value: "triniti940@bmobilerk.com" },
			});
			fireEvent.change(screen.getByLabelText("Password"), {
				target: { value: "TestUser123!" },
			});

			// Submit the form
			fireEvent.click(screen.getByRole("button", { name: "Masuk" }));
		});

		// Assertions
		expect(appPostMock).toHaveBeenCalledWith(
			"login",
			{ email: "triniti940@bmobilerk.com", password: "TestUser123!" },
			{
				headers: {
					"Content-Type": "application/json",
					Accept: "*/*",
				},
			}
		);
		expect(window.location.href).toBe("/");
		expect(toastErrorMock).not.toHaveBeenCalled();

		// Clean up
		appPostMock.mockRestore();
		toastErrorMock.mockRestore();
	});

	// Email input field is empty, submits form, and receives error message
	it("should display error message when email input field is empty", async () => {
		// Mock the necessary dependencies
		const appPostMock = jest.spyOn(app, "post");

		// Render the component
		render(
			<BrowserRouter>
				<ValidationContextProvider>
					<Login />
				</ValidationContextProvider>
			</BrowserRouter>
		);

		act(() => {
			// Fill in the form fields
			fireEvent.change(screen.getByLabelText("Password"), {
				target: { value: "TestUser123!" },
			});

			// Submit the form
			fireEvent.click(screen.getByRole("button", { name: "Masuk" }));
		});

		// Assertions
		waitFor(() => {
			expect(screen.findByText("Email tidak valid")).toBeInTheDocument();
		});
		// Clean up
		appPostMock.mockRestore();
	});

	// Password input field is empty, submits form, and receives error message
	it("should display error message when password input field is empty", async () => {
		const appPostMock = jest.spyOn(app, "post");

		// Render the component
		render(
			<BrowserRouter>
				<ValidationContextProvider>
					<Login />
				</ValidationContextProvider>
			</BrowserRouter>
		);

		act(() => {
			// Fill in the form fields
			fireEvent.change(screen.getByLabelText("Email"), {
				target: { value: "triniti940@bmobilerk.com" },
			});

			// Submit the form
			fireEvent.click(screen.getByRole("button", { name: "Masuk" }));
		});

		// Assertions
		waitFor(() => {
			expect(
				screen.findByText(
					"Password tidak boleh kurang dari 8 atau lebih dari 20 karakter"
				)
			).toBeInTheDocument();
		});

		// Clean up
		appPostMock.mockRestore();
	});

	// Email input field is invalid format, submits form, and receives error message
	it("should display error message when email input field is in invalid format", async () => {
		const appPostMock = jest.spyOn(app, "post");

		// Render the component
		render(
			<BrowserRouter>
				<ValidationContextProvider>
					<Login />
				</ValidationContextProvider>
			</BrowserRouter>
		);

		act(() => {
			// Fill in the form fields
			fireEvent.change(screen.getByLabelText("Email"), {
				target: { value: "invalidemail" },
			});
			fireEvent.change(screen.getByLabelText("Password"), {
				target: { value: "password" },
			});

			// Submit the form
			fireEvent.click(screen.getByRole("button", { name: "Masuk" }));
		});

		// Assertions
		waitFor(() => {
			expect(screen.findByText("Email tidak valid")).toBeInTheDocument();
		});
		// Clean up
		appPostMock.mockRestore();
	});
});
